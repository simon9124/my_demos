# WeakMap

- WeakMap 是 ECMAScript6 的新增特性，是一种新的**集合类型**，是 Map 的“兄弟”类型，也是 Map 的子集
- “weak” 描述的是 JS 垃圾回收程序对待“弱映射”中键的方式

  <a href="" target="_blank">相关代码 →</a>

## 基本 API

- 使用**new 关键字**和**WeakMap 构造函数**可以创建一个空的弱映射

```js
const wm = new WeakMap()
console.log(wm) // WeakMap {}
```

- 若映射的**键**只能是**Object**或者**继承自 Object 的类型**（非对象设置键会报错），值的类型无限制

```js
// 使用嵌套数组初始化若映射
const key1 = { id: 1 },
  key2 = { id: 2 },
  key3 = { id: 3 }

const wm1 = new WeakMap([
  [key1, 'val1'],
  [key2, 'val2'],
  [key3, 'val3'],
])
console.log(wm1.get(key1)) // 'val1'
console.log(wm1.get(key2)) // 'val2'
console.log(wm1.get(key3)) // 'val3'

// 只要有一个键无效就会抛出错误，导致初始化失败
const wm2 = new WeakMap([
  [key1, 'val1'],
  [key2, 'val2'],
  [key3, 'val3'],
  ['key4', 'val4'], // TypeError: Invalid value used as weak map key
])
```

- 可以**将原始值包装成对象**再用作键

```js
const key4 = new String('key4')
const wm3 = new WeakMap([
  [key1, 'val1'],
  [key2, 'val2'],
  [key3, 'val3'],
  [key4, 'val4'],
])
console.log(wm3.get(key4)) // 'val4'
```

- 初始化后，可以使用`set()`添加键/值对，使用`get()`和`has()`进行查询，使用`delete()`删除值（同 Map ，但 WeakMap 没有 clear()方法，也没有自带的 size 属性）

```js
const wm4 = new WeakMap()
console.log(wm4.size) // undefined，WeakMap不自带size属性

const key5 = { id: 1 },
  key6 = { id: 2 }

wm4.set(key5, 'Matt').set(key6, 'Frisbie')
console.log(wm4.has(key5)) // true
console.log(wm4.get(key5)) // 'Matt'

wm4.delete(key5) // 删除这个键值对
console.log(wm4.has(key5)) // false
console.log(wm4.get(key5)) // undefined
console.log(wm4.has(key6)) // true

// wm4.clear() // TypeError: wm4.clear is not a function，WeakMap没有clear方法
```

- `set()`方法返回弱映射实例，因此可以把多个操作连缀起来，从初始化到添加键/值对（同 Map）

```js
const wm5 = new WeakMap().set(key5, 'Matt')
console.log(wm5) // WeakMap { { id: 1 } => 'Matt' }
```

## 弱键

- 弱映射的**键**不属于正式的引用，**不会阻止垃圾回收**
- 只要**键存在**，**键/值就存在**于映射中，并被当作对值的引用，**不会被垃圾回收**

```js
const wm6 = new WeakMap()
wm6.set({}, 'val') // 初始化一个新对象作为建，没有指向这个对象的其他引用，代码执行后键和值均会被当作垃圾回收

const wm7 = new WeakMap()
const container = { key: {} } // container对象维护着wm7中键的引用
wm7.set(container.key, 'val') // 键和值均不会成为垃圾回收的目标
container.key = null // 切断键对象的引用，键和值才会被垃圾回收
```

## 不可迭代键

- 弱映射中的键值对在**任何时候都能被销毁**，因此**没有迭代键值对的方法**
- 弱映射之所以**只能用对象作为键**是为了**保证只有通过键对象的引用才能取得值**

## 使用弱映射

### 私有变量

### DOM 节点元数据

## 总结 & 问点

- WeakMap 属于什么类型？如何创建 WeakMap 类型？初始化后可以对其进行哪些操作？
- WeakMap 的键有什么限制？如果想使用原始值作为建，需要怎样的操作？
