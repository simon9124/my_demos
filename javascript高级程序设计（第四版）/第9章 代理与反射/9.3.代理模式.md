# 代理模式

<a href="" target="_blank">相关代码 →</a>

## 跟踪属性访问

- 通过捕获`get`、`set`、`has`等操作，可以**监控**对象何时何处被访问过

```js
const user = {
  name: 'Jake',
}
const proxy = new Proxy(user, {
  get(target, property, receiver) {
    console.log(`Getting ${property}`)
    return Reflect.get(...arguments)
  },
  set(target, property, value, receiver) {
    console.log(`Setting ${property}=${value}`)
    return Reflect.set(...arguments)
  },
})
proxy.name // 'Getting name'，触发get()拦截
proxy.age = 27 // 'Setting age=27'，触发set()拦截
```

## 隐藏属性

- 代理的内部实现对外部代码不可见，可**隐藏**目标对象的指定属性

```js
const hiddenProperties = ['foo', 'bar'] // 要隐藏的键
const targetObject = {
  // 目标对象
  foo: 1,
  bar: 2,
  baz: 3,
}
const proxy2 = new Proxy(targetObject, {
  get(target, property) {
    if (hiddenProperties.includes(property)) {
      return undefined // 隐藏属性
    } else {
      return Reflect.get(...arguments)
    }
  },
  has(target, property) {
    if (hiddenProperties.includes(property)) {
      return undefined // 隐藏属性
    } else {
      return Reflect.get(...arguments)
    }
  },
})

// get()拦截
console.log(proxy2.foo) // undefined，在代理内部被隐藏
console.log(proxy2.bar) // undefined，在代理内部被隐藏
console.log(proxy2.baz) // 3

// has()拦截
console.log('foo' in proxy2) // false，在代理内部被隐藏
console.log('bar' in proxy2) // false，在代理内部被隐藏
console.log('baz' in proxy2) // true
```

## 属性验证

- 所有的**赋值**操作都会触发`set()`捕获器，可根据所赋的值决定**允许**还是**拒绝**赋值

```js
const target = {
  onlyNumberGoHere: 0,
}
const proxy3 = new Proxy(target, {
  set(target, property, value) {
    if (typeof value !== 'number') {
      return false
    } else {
      return Reflect.set(...arguments)
    }
  },
})
proxy3.onlyNumberGoHere = 1 // 拦截操作，所赋的值为Number类型
console.log(proxy3.onlyNumberGoHere) // 1，赋值成功
proxy3.onlyNumberGoHere = '2' // 拦截操作，所赋的值为String类型
console.log(proxy3.onlyNumberGoHere) // 1，赋值失败
```

## 函数与构造函数参数验证

## 数据绑定与可观察对象

## 总结 & 问点

- 使用代理写一段代码，监控对象在何时何处被访问
- 使用代理写一段代码，隐藏目标对象的指定属性
- 使用代理写一段代码，根据所赋的值决定允许或拒绝给对象赋值
