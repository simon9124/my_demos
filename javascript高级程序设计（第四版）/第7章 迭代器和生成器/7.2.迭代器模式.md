# 迭代器模式

- ES6 新增了 2 个高级特性：**迭代器**和**生成器**

| 迭代方法       | 优/缺点                                            |
| -------------- | -------------------------------------------------- |
| `for`          | ① 需知道如何使用数据结构 ② 遍历顺序不是固有的      |
| `forEach()`    | ① 无法标识迭代终止 ② 只适用数组 ③ 回调结构较笨拙   |
| `Iterator`接口 | 无需了解可迭代对象的结构，只需知道如何取得连续的值 |

## 可迭代协议

- 实现 Iterable 接口要求同时具备：① 支持迭代的自我识别 ② 创建实现 Iterator 接口的对象
- 必须暴露一个属性作为**默认迭代器**，属性使用**Symbol.iterator**作为键
- 默认迭代属性必须引用一个**迭代器工厂函数**，调用工厂函数返回一个**新迭代器**
- 实现了 Iterable 接口的内置类型：**字符串、数组、映射、集合、arguments 对象、NodeList 等 DOM 集合类型**

```js
// 未实现迭代器工厂函数
let num = 1
let obj = {}
console.log(num[Symbol.iterator]) // undefined
console.log(obj[Symbol.iterator]) // undefined

// 实现了迭代器工厂函数
let str = 'abc'
let arr = ['a', 'b', 'c']
let map = new Map().set('a', 1).set('b', 2)
let set = new Set().add('a').add('b')
console.log(str[Symbol.iterator]) // ƒ [Symbol.iterator]() { [native code] }
console.log(arr[Symbol.iterator]) // ƒ values() { [native code] }
console.log(map[Symbol.iterator]) // ƒ entries() { [native code] }
console.log(set[Symbol.iterator]) // ƒ values() { [native code] }

// 调用迭代器工厂函数，生成新的迭代器
console.log(str[Symbol.iterator]()) // StringIterator {}
console.log(arr[Symbol.iterator]()) // ArrayIterator {}
console.log(map[Symbol.iterator]()) // MapIterator { "a" => 1, "b" => 2 }
console.log(set[Symbol.iterator]()) // StringIterator { "a", "b" }
```

- 不需要显示调用迭代器工厂函数，实现可迭代协议的**所有类型**都**自动兼容接受**可迭代对象的任何语言特性
- **接受可迭代对象的原生语言特性**包括：
  - `for-of`循环
  - 数组解构
  - 扩展操作符
  - `Array.from()`
  - 创建集合
  - 创建映射
  - `Promise.all()`接收由期约组成的可迭代对象
  - `Promise.race()`接收由期约组成的可迭代对象
  - `yield*`操作符，在生成器中使用

```js
for (let el of arr) {
  console.log(el) // for-of循环
  /* 
    'a'
    'b'
    'c'
   */
}

let [a, b, c] = arr // 数组解构
console.log(a, b, c) // 'a' 'b' 'c'

let arr2 = [...arr] // 扩展操作符
console.log(arr2) // [ 'a', 'b', 'c' ]

let arr3 = Array.from(arr) // Array.from()
console.log(arr3) // [ 'a', 'b', 'c' ]

let set2 = new Set(arr)
console.log(set2) // Set(3) { 'a', 'b', 'c' }

let pairs = arr.map((x, i) => [x, i])
console.log(pairs) // [ [ 'a', 0 ], [ 'b', 1 ], [ 'c', 2 ] ]
let map2 = new Map(pairs)
console.log(map2) // Map(3) { 'a' => 0, 'b' => 1, 'c' => 2 }
```

- 如果对象原型链上的**父类实现了 Iterabe 接口**，该对象也实现了这个接口

```js
class FooArray extends Array {}
let fooArr = new FooArray('foo', 'bar', 'baz')

for (let el of fooArr) {
  console.log(el)
  /* 
    foo
    bar
    baz
   */
}
```

## 迭代器协议

- 迭代器 API 使用`next()`方法在可迭代对象中遍历数据，每次成功调用`next()`都返回一个`IteratorResult`对象：
  - `IteratorResult`包含 2 个属性**done**和**value**
  - `done` 是一个布尔值，false 为未耗尽，true 为耗尽
  - `value`包含可迭代对象的下一个值（若 done 为 true 则 value 为 undefined）
  - 迭代第到达`done:true`状态，后续再调用`next()`一直返回`{done:true,value:undefined}`

```js
let arr4 = ['foo', 'bar'] // 可迭代对象
console.log(arr4[Symbol.iterator]) // ƒ values() { [native code] }，迭代器工厂函数

let iter = arr4[Symbol.iterator]() // 迭代器
console.log(iter) // ArrayIterator {}

console.log(iter.next()) // { value: 'foo', done: false }，执行迭代
console.log(iter.next()) // { value: 'foo', done: false }，执行迭代
console.log(iter.next()) // { value: undefined, done: true }，执行迭代
console.log(iter.next()) // { value: undefined, done: true }，执行迭代
```

- 不同迭代器实例之间没有联系，每个迭代器都独立地遍历可迭代对象

```js
let iter2 = arr4[Symbol.iterator]() // 迭代器iter2，迭代可迭代对象arr4
let iter3 = arr4[Symbol.iterator]() // 迭代器iter2，迭代可迭代对象arr4

console.log(iter2.next()) // { value: 'foo', done: false }
console.log(iter3.next()) // { value: 'foo', done: false }
console.log(iter3.next()) // { value: 'bar', done: false }
console.log(iter2.next()) // { value: 'bar', done: false }
```

- 可迭代对象在迭代期间被修改

## 自定义迭代器

## 提前终止迭代器

## 总结 & 问点

- 实现迭代有哪些方式？其优、缺点分别是什么？默认迭代器必须使用什么属性作为键？
- 如何检测数据类型是否实现了迭代器工厂函数？调用这个工厂函数会生成什么？
- 迭代器 API 使用什么方法遍历数据？其返回值是什么？
-
