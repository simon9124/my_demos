# 期约

- 期约是对尚不存在结果的一个替身，是一种异步程序执行的机制

<a href="" target="_blank">相关代码 →</a>

## Promises/A+规范

- ES6 新增了`Promise`类型，其成为主导性的异步编程机制，所有现代浏览器都支持期约

## 期约基础

- `Promise`类型通过`new`操作符实例化，需传入**执行器（executor）函数**作为参数

```js
// let p = new Promise() // TypeError: Promise resolver undefined is not a function，必须提供执行器函数作为参数
let p = new Promise(() => {})
setTimeout(console.log, 0, p) // Promise { <pending> }
```

### 期约状态机

- 期约是一个有状态的对象：
  - 待定`pending`表示**尚未开始或正在执行**。最初始状态，可以落定为兑现或拒绝状态，**兑现后不可逆**
  - 兑现`fullfilled`（或解决`resolved`）表示成功完成
  - 拒绝`rejected`表示没有成功完成
- 期约的状态是**私有**的，其将异步行为**封装**起来**隔离**外部代码，**不能**被外部 JS 代码读取或修改

### 解决值、拒绝理由及期约用例

- 期约的状态机可以提供很有用的信息，假设其向服务器发送一个 HTTP 请求：
  - 返回 200-299 范围内的状态码,可让期约状态变为“兑现”，期约**内部**收到**私有**的`JSON`字符串，默认值为 undefined
  - 返回不在 200-299 范围内的状态码，会把期约状态切换为“拒绝”，期约**内部**收到**私有**的`Error`对象（包含错误消息），默认值为 undefined

### 通过执行函数控制期约状态

- 期约的状态是**私有**的，只能在**执行器函数**中完成**内部操作**
- 执行器函数负责**初始化期约异步行为**和**控制状态转换**：
  - 通过`resolve()`和`reject()`两个函数参数控制状态转换
  - `resolve()`会把状态切换为**兑换**，`reject()`会把状态切换为**拒绝**并**抛出错误**

```js
let p1 = new Promise((resolve, reject) => resolve())
setTimeout(console.log, 0, p1) // Promise {<fulfilled>: undefined}

let p2 = new Promise((resolve, reject) => reject())
setTimeout(console.log, 0, p2) // Promise {<rejected>: undefined}
// Uncaught (in promise)
```

- 执行器函数是期约的初始化程序，其是**同步**执行的

```js
new Promise(() => setTimeout(console.log, 0, 'executor'))
setTimeout(console.log, 0, 'promise initialized')
/* 
  'executor'，先打印
  'promise initialized'，后打印
*/
```

- 可添加`setTimeout`推迟执行器函数的切换状态

```js
let p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000)
})
setTimeout(console.log, 0, p3) // Promise { <pending> }，打印实例p3时，还不会执行内部回调
```

- `resolve()`和`reject()`无论哪个被调用，状态转换都**不可撤销**，继续修改状态会**静默失败**

```js
let p4 = new Promise((resolve, reject) => {
  resolve()
  reject() // 静默失败
})
setTimeout(console.log, 0, p4) // Promise {<fulfilled>: undefined}
```

- 为避免期约卡在待定状态，可**添加定时退出**功能，设置若干时长后无论如何都拒绝期约的回调

```js
let p5 = new Promise((resolve, reject) => {
  setTimeout(reject, 10000) // 10秒后调用reject()
})
setTimeout(console.log, 0, p5) // Promise { <pending> }，10秒内，不调用resolve()
setTimeout(console.log, 11000, p5) // Promise {<rejected>: undefined}，10秒外，调用reject()
// Uncaught (in promise)
```

### Promise.resolve()

- 调用`Promise.resolve()`方法，可以**实例化**一个**解决的**期约

```js
let p6 = new Promise((resolve, reject) => {
  resolve()
})
console.log(p6) // Promise {<fulfilled>: undefined}
let p7 = Promise.resolve()
console.log(p7) // Promise {<fulfilled>: undefined}
```

- 传给`Promise.resolve()`的**第一个参数**为解决的期约的值

```js
setTimeout(console.log, 0, Promise.resolve()) // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, Promise.resolve(3)) // Promise {<fulfilled>: 3}
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)) // Promise {<fulfilled>: 4}，只取首个参数
```

- `Promise.resolve()`是一个**幂等**方法，如果传入的**参数是一个期约**，其行为类似于一个**空包装**

```js
let p8 = Promise.resolve(7)
setTimeout(console.log, 0, Promise.resolve(p8)) // Promise { 7 }
setTimeout(console.log, 0, p8 === Promise.resolve(p8)) // true
setTimeout(console.log, 0, p8 === Promise.resolve(Promise.resolve(p8))) // true
```

- 该幂等性会**保留**传入期约的**状态**

```js
let p9 = new Promise(() => {}) // 待定状态
setTimeout(console.log, 0, p9) // Promise { <pending> }
setTimeout(console.log, 0, Promise.resolve(p9)) // Promise { <pending> }
setTimeout(console.log, 0, Promise.resolve(Promise.resolve(p9))) // Promise { <pending> }
```

- 该方法能够包装**任何非期约值**（包括错误对象），并将其**转换为解决的期约**，因此可能导致不符合预期的行为

```js
let p10 = Promise.resolve(new Error('foo'))
setTimeout(console.log, 0, p10) // Promise {<fulfilled>: Error: foo
```

### Promise.reject()

- 与`Promise.resolve()`相似，`Promise.reject()`可以**实例化**一个**拒绝的**期约并**抛出一个异步错误**
  - 该错误**不能**通过`try/catch`捕获，只能通过拒绝处理程序捕获

```js
let p11 = new Promise((resolve, reject) => {
  reject()
})
console.log(p11) // Promise {<rejected>: undefined}
// Uncaught (in promise)

let p12 = Promise.reject()
console.log(p12) // Promise {<rejected>: undefined}
// Uncaught (in promise)
```

- 传给`Promise.resolve()`的**第一个参数**为拒绝的期约的理由，该参数也会**传给后续的拒绝处理程序**

```js
let p13 = Promise.reject(3)
setTimeout(console.log, 0, p13) // Promise { <rejected> 3 }
p13.then(null, (err) => setTimeout(console.log, 0, err)) // 3，参数传给后续拒绝处理程序
```

- `Promise.reject()`不是幂等的（与`Promise.resolve()`不同），如果参数为期约对象，则该期约会成为返回的拒绝理由

```js
setTimeout(console.log, 0, Promise.reject(Promise.resolve())) // Promise {<rejected>: Promise}
```

### 同步/异步执行的二元性

- 由于期约的**异步特性**，其虽然是同步对象（可在同步执行模式中使用），但也是异步执行模式的媒介
  - **同步线程的代码无法捕获拒绝的期约**，拒绝期约的错误会通过**浏览器异步消息队列**来处理
  - 代码一旦开始以异步模式执行，唯一与之交互的方式就是**使用异步结构**，即期约

```js
try {
  throw new Error('foo') // 同步线程抛出错误
} catch (error) {
  console.log(error + '1') // Error: foo1，同步线程捕获错误
}

try {
  Promise.reject('bar') // 同步线程使用期约
} catch (error) {
  console.log(error + '2') // 同步线程捕获不到拒绝的期约
}
// Promise {<rejected>: "bar"}，浏览器异步消息队列捕获到拒绝的期约
// Uncaught (in promise) bar
```

## 期约的实例方法

- 这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果

### 实现 Thenable 接口

- ECMAScript 暴露的异步结构中，任何对象都有一个`then()`方法，该方法被认为实现了`thenable`接口

```js
class MyThenable {
  // 实现Thenable接口的最简单的类
  then() {}
}
```

### Promise.prototype.then()

- `Promise.prototype.then()`为期约**添加处理程序**，接收**2 个可选的处理程序参数**`onResolved`和`onRejected`
  - `onResolved`会在期约进入**兑现**状态时执行
  - `onRejected`会在期约进入**拒绝**状态时执行

```js
function onResolved(id) {
  setTimeout(console.log, 0, id, 'resolved')
}
function onRejected(id) {
  setTimeout(console.log, 0, id, 'rejected')
}
let p14 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000)
})
let p15 = new Promise((resolve, reject) => {
  setTimeout(reject, 3000)
})

p14.then(
  () => {
    onResolved('p14') // 'p14 resolved'（3秒后）
  },
  () => {
    onRejected('p14')
  }
)
p15.then(
  () => {
    onResolved('p15')
  },
  () => {
    onRejected('p15') // 'p15 rejected'（3秒后）
  }
)
```

- 传给`then()`的任何非函数类型的参数都会被静默忽略（不推荐），如果只提供`onResolved`或`onRejected`，一般在另一个参数位置上传入`null`或`undefined`

```js
p14.then('gobbeltygook') // 参数不是对象，静默忽略
p14.then(() => onResolved('p14')) // 'p14 resolved'（3秒后），不传onRejected
p15.then(null, () => onRejected('p15')) // 'p15 rejected'（3秒后），不传onResolved
```

- `Promise.prototype.then()`返回一个**新的期约实例**，该实例基于`onResolved`处理程序（`Promise.resolved()`包装）的返回值构建
  - 若**没有提供这个处理程序**，则包装**上一个**期约解决之后的值
  - 若提供了处理程序，但**没有显示的返回语句**，则包装默认的返回值 `undefined`
  - 若提供了处理程序，且**有显示的返回值**，则包装**这个值**
  - 若提供了处理程序，且**返回期约**，则包装**返回的期约**
  - 若提供了处理程序，且**抛出异常**，则包装**拒绝的期约**
  - 若提供了处理程序，且**返回错误值**，则把**错误对象**包装在一个**解决的期约**中（而非拒绝的期约）

```js
let p16 = Promise.resolve('foo')

let result1 = p16.then() // 没有提供处理程序
setTimeout(console.log, 0, result1) // Promise {<fulfilled>: 'foo'}，包装上一个期约解决后的值

let result2 = p16.then(() => undefined) // 处理程序没有显示的返回语句
let result3 = p16.then(() => {}) // 处理程序没有显示的返回语句
let result4 = p16.then(() => Promise.resolve()) // 处理程序没有显示的返回语句
setTimeout(console.log, 0, result2) // Promise {<fulfilled>: undefined}，包装默认返回值undefined
setTimeout(console.log, 0, result3) // Promise {<fulfilled>: undefined}，包装默认返回值undefined
setTimeout(console.log, 0, result4) // Promise {<fulfilled>: undefined}，包装默认返回值undefined

let result5 = p16.then(() => 'bar') // 处理程序有显示的返回值
let result6 = p16.then(() => Promise.resolve('bar')) // 处理程序有显示的返回值
setTimeout(console.log, 0, result5) // Promise {<fulfilled>: 'bar'}，包装这个值
setTimeout(console.log, 0, result6) // Promise {<fulfilled>: 'bar'}，包装这个值

let result7 = p16.then(() => new Promise(() => {})) // 处理程序返回一个待定的期约
let result8 = p16.then(() => Promise.reject('bar')) // 处理程序返回一个拒绝的期约
// Uncaught (in promise) bar
setTimeout(console.log, 0, result7) // Promise {<pending>}，包装返回的期约
setTimeout(console.log, 0, result8) // Promise {<rejected>: 'bar'}，包装返回的期约

let result9 = p16.then(() => {
  throw 'baz' // 处理程序抛出异常
})
// Uncaught (in promise) baz
setTimeout(console.log, 0, result9) // Promise {<rejected>: 'baz'}，包装拒绝的期约

let result10 = p16.then(() => Error('qux')) // 处理程序返回错误值
setTimeout(console.log, 0, result10) // Promise {<fulfilled>: Error: qux}，把错误对象包装在一个解决的期约中
```

## 总结 & 问点

- 什么是 Promise 类型？如何创建？其不同状态分别表示什么？
- 执行器函数负责的作用是什么？如何推迟其切换状态？如何避免期约卡在待定状态？
- 如何实例化一个解决的期约？其值是什么？若传入的参数也是期约结果会怎样？
- 如何实例化一个拒绝的期约？其拒绝理由是什么？若传入的参数也是期约结果会怎样？
- 如何理解期约的异步特性？如何捕获拒绝的期约？
