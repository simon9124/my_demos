# 期约

- 期约是对尚不存在结果的一个替身，是一种异步程序执行的机制

<a href="" target="_blank">相关代码 →</a>

## Promises/A+规范

- ES6 新增了`Promise`类型，其成为主导性的异步编程机制，所有现代浏览器都支持期约

## 期约基础

- `Promise`类型通过`new`操作符实例化，需传入**执行器（executor）函数**作为参数

```js
// let p = new Promise() // TypeError: Promise resolver undefined is not a function，必须提供执行器函数作为参数
let p = new Promise(() => {})
setTimeout(console.log, 0, p) // Promise { <pending> }
```

### 期约状态机

- 期约是一个有状态的对象：
  - 待定`pending`表示**尚未开始或正在执行**。最初始状态，可以落定为兑现或拒绝状态，**兑现后不可逆**
  - 兑现`fullfilled`（或解决`resolved`）表示成功完成
  - 拒绝`rejected`表示没有成功完成
- 期约的状态是**私有**的，其将异步行为**封装**起来**隔离**外部代码，**不能**被外部 JS 代码读取或修改

### 解决值、拒绝理由及期约用例

- 期约的状态机可以提供很有用的信息，假设其向服务器发送一个 HTTP 请求：
  - 返回 200-299 范围内的状态码,可让期约状态变为“兑现”，期约**内部**收到**私有**的`JSON`字符串，默认值为 undefined
  - 返回不在 200-299 范围内的状态码，会把期约状态切换为“拒绝”，期约**内部**收到**私有**的`Error`对象（包含错误消息），默认值为 undefined

### 通过执行函数控制期约状态

- 期约的状态是**私有**的，只能在**执行器函数**中完成**内部操作**
- 执行器函数负责**初始化期约异步行为**和**控制状态转换**：
  - 通过`resolve()`和`reject()`两个函数参数控制状态转换
  - `resolve()`会把状态切换为**兑换**，`reject()`会把状态切换为**拒绝**并**抛出错误**

```js
let p1 = new Promise((resolve, reject) => resolve())
setTimeout(console.log, 0, p1) // Promise {<fulfilled>: undefined}

let p2 = new Promise((resolve, reject) => reject())
setTimeout(console.log, 0, p2) // Promise {<rejected>: undefined}
// Uncaught (in promise)
```

- 执行器函数是期约的初始化程序，其是**同步**执行的

```js
new Promise(() => setTimeout(console.log, 0, 'executor'))
setTimeout(console.log, 0, 'promise initialized')
/* 
  'executor'，先打印
  'promise initialized'，后打印
*/
```

- 可添加`setTimeout`推迟执行器函数的切换状态

```js
let p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000)
})
setTimeout(console.log, 0, p3) // Promise { <pending> }，打印实例p3时，还不会执行内部回调
```

- `resolve()`和`reject()`无论哪个被调用，状态转换都**不可撤销**，继续修改状态会**静默失败**

```js
let p4 = new Promise((resolve, reject) => {
  resolve()
  reject() // 静默失败
})
setTimeout(console.log, 0, p4) // Promise {<fulfilled>: undefined}
```

- 为避免期约卡在待定状态，可**添加定时退出**功能，设置若干时长后无论如何都拒绝期约的回调

```js
let p5 = new Promise((resolve, reject) => {
  setTimeout(reject, 10000) // 10秒后调用reject()
})
setTimeout(console.log, 0, p5) // Promise { <pending> }，10秒内，不调用resolve()
setTimeout(console.log, 11000, p5) // Promise {<rejected>: undefined}，10秒外，调用reject()
// Uncaught (in promise)
```

### Promise.resolve()

- 调用`Promise.resolve()`方法，可以**实例化**一个解决的期约

```js
let p6 = new Promise((resolve, reject) => {
  resolve()
})
console.log(p6) // Promise {<fulfilled>: undefined}
let p7 = Promise.resolve()
console.log(p7) // Promise {<fulfilled>: undefined}
```

- 传给`Promise.resolve()`的**第一个参数**为解决的期约的值

```js
setTimeout(console.log, 0, Promise.resolve()) // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, Promise.resolve(3)) // Promise {<fulfilled>: 3}
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)) // Promise {<fulfilled>: 4}，只取首个参数
```

- `Promise.resolve()`是一个**幂等**方法，如果传入的**参数是一个期约**，其行为类似于一个**空包装**

```js
let p8 = Promise.resolve(7)
setTimeout(console.log, 0, Promise.resolve(p8)) // Promise { 7 }
setTimeout(console.log, 0, p8 === Promise.resolve(p8)) // true
setTimeout(console.log, 0, p8 === Promise.resolve(Promise.resolve(p8))) // true
```

- 该幂等性会**保留**传入期约的**状态**

```js
let p9 = new Promise(() => {}) // 待定状态
setTimeout(console.log, 0, p9) // Promise { <pending> }
setTimeout(console.log, 0, Promise.resolve(p9)) // Promise { <pending> }
setTimeout(console.log, 0, Promise.resolve(Promise.resolve(p9))) // Promise { <pending> }
```

- 该方法能够包装**任何非期约值**（包括错误对象），并将其**转换为解决的期约**，因此可能导致不符合预期的行为

```js
let p10 = Promise.resolve(new Error('foo'))
setTimeout(console.log, 0, p10) // Promise {<fulfilled>: Error: foo
```

### Promise.reject()

## 总结 & 问点

- 什么是 Promise 类型？如何创建？其不同状态分别表示什么？
- 执行器函数负责的作用是什么？如何推迟其切换状态？如何避免期约卡在待定状态？
- 如何实例化一个解决的期约？其值是什么？若传入的参数也是期约结果会怎样？
