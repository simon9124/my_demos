# 类

- ES6 新引入`class`关键字具有正式定义类的能力，其背后使用的仍然是**原型**和**构造函数**的概念

<a href="" target="_blank">相关代码 →</a>

## 类定义

- 与函数类型类似，定义类也有 2 种主要方式：**类声明**和**类表达式**，2 种方式都是用`class`关键字加大括号

```js
class Person {} // 类声明
var animal = class {} // 类表达式
```

- 类表达式在**被求值前不能引用**（同函数表达式），类定义**不能声明提升**（与函数表达式不同）

```js
console.log(FunctionDeclaration) // [Function: FunctionDeclaration]，函数声明提前
function FunctionDeclaration() {}
console.log(ClassDeclaration) // ReferenceError: Cannot access 'ClassDeclaration' before initialization，类没有声明提前
class ClassDeclaration {}
```

- 类受**块级作用域**限制（函数受**函数作用域**限制）

```js
{
  function FunctionDeclaration2() {}
  class ClassDeclaration2 {}
}
console.log(FunctionDeclaration2) // [Function: FunctionDeclaration2]
console.log(ClassDeclaration2) // ReferenceError: ClassDeclaration2 is not defined
```

### 类的构成

- 类可以包含**构造函数方法**、**实例方法**、**获取函数**、**设置函数**和**静态类方法**，也可以**空类定义**
- 默认情况下，类定义中的代码都在**严格模式**下执行
- **类名**建议**首字母大写**（与构造函数一样），以区分类和实例

```js
class Foo {} // 空类定义
class Bar {
  constructor() {} // 构造函数
  get myBaz() {} // 获取函数
  static myQux() {} // 静态方法
}
```

- 把类表达式赋值给变量后，可以在**类表达式作用域内部**访问类表达式，并通过`name`属性取得**类表达式的名称**

```js
var Person2 = class PersonName {
  identify() {
    console.log(PersonName) // 类表达式作用域内部，访问类表达式
    console.log(Person2.name, PersonName.name) // 类表达式作用域内部，访问类表达式的名称
    /* 
      [class PersonName]
      PersonName PersonName
    */
  }
}
var p = new Person2()
p.identify()
console.log(Person2.name) // PersonName
console.log(PersonName) // ReferenceError: PersonName is not defined，类表达式作用与外部，无法访问类表达式
```

## 类构造函数

- 在类定义块内部用`constructor`关键字创建**类的构造函数**：
  - 使用`new`操作符创建**类的实例**时，调用`constructor`方法
  - 构造函数的定义**非必需**，**不定义**构造函数相当于将构造函数定义为**空函数**

### 实例化

- 使用`new`操作符调用**类的构造函数**会执行如下操作（同构造函数）：
  - 创建了一个新对象（实例）
  - 新对象内部的`[[Prototype]]`特性被赋值为构造函数的`prototype`属性（共同指向原型）
  - 将构造函数的作用域（即 this）赋给新对象
  - 执行构造函数中的代码（即：为这个对象添加新属性）
  - 返回新对象或非空对象

```js
class Animal2 {}
class Person3 {
  constructor() {
    console.log('person ctor')
  }
}
class Vegetable {
  constructor() {
    this.color = 'orange'
  }
}
var a = new Animal2()
var p = new Person3() // 'person ctor'
var v = new Vegetable()
console.log(v.color) // 'orange'
```

- 类实例化时，**传入的参数**会用做**构造函数的参数**（无参数则类名后可不加括号）

```js
var p1 = new Person4() // 0，无参数，Person4后的括号也可省略
console.log(p1.name) // null
var p2 = new Person4('Jake') // 1
console.log(p2.name) // 'Jake'
```

- 默认情况下，类构造函数会在执行后**返回`this`对象**（类实例），如果**返回的不是`this`对象**，则该对象用`instanceof`操作符检测时**与类无关联**

```js
class Person5 {
  constructor() {
    this.foo = 'foo'
  }
}
var p3 = new Person5()
console.log(p3) // Person5 { foo: 'foo' }，类实例
console.log(p3.__proto__) // {}，类原型
console.log(p3.constructor) // [class Person5]，类本身当作构造函数
console.log(Person5 === p3.constructor) // true
console.log(Person5.prototype === p3.__proto__) // true
console.log(p3 instanceof Person5) // true，p3是Person5的实例（Person5.prototype在p3的原型链上）

class Person6 {
  constructor() {
    return {
      bar: 'bar', // 返回一个全新的对象（不是该类的实例）
    }
  }
}
var p4 = new Person6()
console.log(p4) // { bar: 'bar' }，不是Person6的类实例
console.log(p4.__proto__) // {}，Object原型
console.log(p4.constructor) // [Function: Object]，Object构造函数
console.log(Object === p4.constructor) // true
console.log(Object.prototype === p4.__proto__) // true
console.log(p4 instanceof Person6) // false，p4不是Person6的实例（Person6.prototype不在p4的原型链上）
```

- **类构造函数**与**构造函数**的**主要区别**是：类构造函数必须使用`new`操作符，普通构造函数可以不使用`new`操作符（当作普通函数调用）

```js
function Person7() {} // 普通构造函数
class Animal3 {} // 类构造函数
var p5 = Person7() // 构造函数不使用new操作符，当作普通函数调用
var a1 = Animal3() // TypeError: Class constructor Animal3 cannot be invoked without 'new'，类构造函数必须使用new操作符实例化
var a2 = new Animal3()
```

- 类构造函数**实例化后**，会成为普通的**实例方法**，可以使用`new`操作符**在实例上引用**它

```js
class Person8 {
  constructor() {
    console.log('foo')
  }
}
var p6 = new Person8() // 'foo'
// p6.constructor() // TypeError: Class constructor Person8 cannot be invoked without 'new'
new p6.constructor() // 'foo'
```

### 把类当成特殊函数

- 类是一种**特殊函数**，可用`typeof`操作符检测

```js
console.log(typeof Person8) // function
```

- 类标识具有`prototype`属性（指向原型），原型的`constructor`属性（默认）指向**类自身**

```js
console.log(Person8.prototype) // {}，原型
console.log(Person8.prototype.constructor) // [class Person8]，类自身
console.log(Person8.prototype.constructor === Person8) // true
```

- 可以使用`instanceof`操作符检查**类`prototype`指向的对象**是否存在于**类实例**的原型链中

```js
console.log(p6 instanceof Person8) // true，p6是Person8的实例
```

- 使用`new`操作符调用**类本身**时，**类本身**被当成构造函数，类实例的`constructor`指向类本身
- 使用`new`操作符调用**类构造函数**时，**类构造函数（`constructor()`）**被当成构造函数，类实例的`constructor`指向 Function 构造函数

```js
class Person9 {}
console.log(Person9.constructor) // [Function: Function]，指向Function原型的constructor，即Function构造函数

var p7 = new Person9() // new调用类本身，类本身被当作构造函数
console.log(p7.constructor) // [class Person9]，constructor指向构造函数，即类本身
console.log(p7.constructor === Person9) // true
console.log(p7 instanceof Person9) // true，p7是Person9的实例

var p8 = new Person9.constructor() // new调用类构造函数，类构造函数（constructor()）被当作构造函数
console.log(p8.constructor) // [Function: Function]，constructor指向构造函数，即Function构造函数
console.log(p8.constructor === Function) // true
console.log(p8 instanceof Person9.constructor) // true，p8是Person9.constructor的实例
```

- 可以**把类当作参数**传递

```js
let classList = [
  class {
    constructor(id) {
      this._id = id
      console.log(`instance ${this._id}`)
    }
  },
]
function createInstance(classDefinition, id) {
  return new classDefinition(id)
}
var foo = new createInstance(classList[0], 3141) // 'instance 3141'
```

- 类可以**立即实例化**

```js
var p9 = new (class Foo2 {
  constructor(x) {
    console.log(x) // 'bar'
  }
})('bar')
console.log(p9) // Foo2 {}，类实例
console.log(p9.constructor) // [class Foo2]，类本身
```

## 实例、原型和类成员

## 继承

## 总结 & 问点

- 如何定义 JS 的类？类和函数有哪些异同？
- 类可以包含哪些内容？如何访问类表达式及其名称？
- 类实例化时内部历经哪些步骤？类构造函数默认返回什么？若返回一个新对象会有什么印象？
- 类构造函数与普通构造函数的主要区别是什么？
- 类属于什么数据类型？其 prototype 和 constructor 分别指向什么？使用 new 操作符调用类本身和类构造函数有什么区别？
- 写 2 段代码，分别表述“类当作参数”及“类立即实例化”
