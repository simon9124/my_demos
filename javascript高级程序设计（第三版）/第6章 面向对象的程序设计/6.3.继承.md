# 继承

- 面向对象语言支持 2 种继承方式：**接口继承**和**实现继承**
- JS 函数没有签名（不必提前声明变量的类型），只支持**实现继承**，依靠**原型链**

## 原型链

- 子类型构造函数的**原型**，被**重写**为超类型构造函数的**实例**

```js
function SuperType() {
  this.property = true
}
SuperType.prototype.getSuperValue = function () {
  return this.property
}
function SubType() {}
SubType.prototype = new SuperType() // SubType的原型 = SuperType的实例，SubType原型被重写 → SubType 继承了 SuperType

console.log(SubType.prototype.__proto__) // SuperType原型，SuperType实例的[[Prototype]]指向SuperType原型
console.log(SubType.prototype.__proto__.constructor) // SuperType构造函数，SuperType原型的constructor指向SuperType构造函数
```

- 超类型**实例中**的**属性和方法**，均存在于子类型的原型中
- 子类型的实例可访问超类型**原型上的方法**，方法仍存在于超类型的原型中

```js
var instance = new SubType()
console.log(instance.property) // true，SubType继承了property属性
console.log(SubType.prototype.hasOwnProperty('property')) // true，property是SuperType的实例属性，SubType的原型已被重写为SuperType的实例
console.log(instance.getSuperValue()) // true，SubType继承了getSuperValue()方法
console.log(SubType.prototype.hasOwnProperty('getSuperValue')) // false，getSuperValue是SuperType的原型方法，不存在于SubType的实例中
console.log(SuperType.prototype.hasOwnProperty('getSuperValue')) // true
```

- 调用子类型构造函数创建实例后，由于子类型的原型被重写：
  - 实例的 [[Prototype]]指向超类型的实例（原本指向子类型的原型）
  - 实例的 constructor 指向重写原型对象的构造函数，即超类型构造函数（原本指向子类型构造函数）

```js
console.log(instance.__proto__) // SuperType实例，SubType的原型SubType.prototype已被SuperType的实例重写
console.log(instance.constructor) // SuperType构造函数，constructor指向重写原型对象的constructor，即new SuperType()的constructor
console.log(instance.constructor === SubType.prototype.constructor) // true，都指向SuperType构造函数
```

- 实现了原型链后，代码读取对象属性的搜索过程：

  - 1.搜索对象实例本身 -> 有属性 → 返回属性值 -> 结束
  - 2.对象实例本身无属性 -> 搜索原型对象 → 有属性 → 返回属性值 -> 结束
  - 3.原型对象无属性 -> 一环一环向上搜索原型链 → 有/无属性 → 返回属性值/undefined → 结束

### 别忘记默认的原型

- 所有引用类型都**默认继承**了 **Object**，所有函数的**默认原型**都是 **Object 实例**
- 默认原型内部的[[Prototype]]指针，指向 Object 的原型 Object.prototype
- Object.prototype 上保存着 constructor、hasOwnProperty、isPrototypeOf、propertyIsEnumerable、toString、valueOf,toLocaleString 等默认方法，在实例中调用这些方法时，其实调用的是 **Object 原型上的方法**

```js
console.log(SuperType.prototype.__proto__ === Object.prototype) // true，SuperType的默认原型是Object的实例，Object实例的__proto__指向Object原型
console.log(SuperType.prototype.__proto__.constructor) // Object构造函数
console.log(Object.getOwnPropertyNames(SuperType.prototype.__proto__)) // [ 'constructor','__defineGetter__','__defineSetter__','hasOwnProperty','__lookupGetter__','__lookupSetter__','isPrototypeOf','propertyIsEnumerable','toString','valueOf','__proto__','toLocaleString' ]，Object原型上的所有方法
```

### 确定原型和实例的关系

- instanceof 操作符，测试**实例**与**原型链中出现过的构造函数**
- instanceof 具体含义：判断一个**构造函数的 prototype 属性所指向的对象**，是否存在于**要检测对象（实例）**的**原型链**上

```js
console.log(instance instanceof Object) // true，instance是Object的实例
console.log(instance instanceof SuperType) // true，instance是SuperType的实例
console.log(instance instanceof SubType) // true，instance是SubType的实例
```

- isPrototypeOf()方法，测试**实例**与**原型链上的原型**
- isPrototypeOf() 具体含义：判断一个**对象（原型对象）**是否存在于**要检测对象（实例）**的**原型链**上

```js
console.log(Object.prototype.isPrototypeOf(instance)) // true，Object.prototype是instance原型链上的原型
console.log(SuperType.prototype.isPrototypeOf(instance)) // true，SuperType.prototype是instance原型链上的原型
console.log(SubType.prototype.isPrototypeOf(instance)) // true，SubType.prototype是instance原型链上的原型
```

### 谨慎地定义方法

- 给子类型原型或超类型原型**添加或重写方法的代码**，一定要放在**替换原型语句**之后

```js
...
SubType.prototype = new SuperType() // 替换原型语句

// 给子类型原型添加新方法
SubType.prototype.getSubValue = function () {
  return false
}
// 在子类型原型中重写超类型原型的方法
SubType.prototype.getSuperValue = function () {
  return false
}

var instance2 = new SubType()
console.log(instance2.getSubValue()) // false
console.log(instance2.getSuperValue()) // false，方法被重写
var instance3 = new SuperType()
console.log(instance3.getSuperValue()) // true，不影响超类型原型中的方法
```

- 通过原型链实现继承时，**不能使用对象字面量创建原型方法**，因为这样会**重写原型链，导致继承关系失效**

```js
function SubType2() {}
SubType2.prototype = new SuperType() // 继承

SubType2.prototype = {
  // 对象字面量重写原型，继承关系失效
  someFunction: function () {
    return false
  },
}
var instance4 = new SubType2()
console.log(instance4.getSuperValue()) // error，对象字面量重写了原型，继承关系已失效
```

### 原型链的问题

- 对**子类型实例**的**引用类型**的属性进行修改（非重新定义）时，会对**超类型实例**的引用类型属性造成影响

```js
function SuperTypePro() {
  this.nums = [1, 2, 3]
  this.name = name
}
SuperTypePro.prototype.getSuperNums = function () {
  return this.nums
}
function SubTypePro() {}
SubTypePro.prototype = new SuperTypePro() // 继承

var instance5 = new SubTypePro()
instance5.nums.push(4) // 非重新定义，而是向超类型实例的数组中添加数据
console.log(instance5.nums) // [1,2,3,4]
var instance6 = new SubTypePro()
console.log(instance6.nums) // [1,2,3,4]，超类型实例的数组受到影响
var instance7 = new SubTypePro()
instance7.nums = [] // 重新定义，覆盖超类型实例中的属性
console.log(instance7.nums) // []
console.log(instance6.nums) // [1,2,3,4]，超类型实例的数组补受影响
```

- 在不影响所有对象实例的情况下，**无法给超类型构造函数传递参数**

```js
var person = new SuperTypePro('Simon')
console.log(person.name) // 'Simon'
var person2 = new SubTypePro('Simon') // 参数传递无意义
console.log(person2.name) // undefined
```

## 借用构造函数

- 在子类型构造函数内部，通过`apply()`或`call()`将**超类型构造函数**的**作用域**绑定给**子类型构造函数**

```js
function SuperTypeBorrow() {
  this.nums = [1, 2, 3]
}
function SubTypeBorrow() {
  console.log(this) // SubTypeBorrow构造函数内部的this，指向SubTypeBorrow的实例
  SuperTypeBorrow.call(this) // 将SuperTypeBorrow的作用域绑定给this，也就是SubTypeBorrow的实例
}
var instance8 = new SubTypeBorrow()
console.log(instance8.nums) // [ 1, 2, 3 ]

instance8.nums.push(4)
console.log(instance8.nums) // [ 1, 2, 3, 4 ]
var instance9 = new SubTypeBorrow()
console.log(instance9.nums) // [ 1, 2, 3 ]
```

### 传递参数

- 可以在子类型构造函数中，向超类型构造函数传递参数
- 为确保超类型构造函数不会重写子类型的属性，**先调用超类型构造函数，再添加子类型中定义的属性**

```js
function SuperTypeParam(name) {
  this.name = name
}
function SubTypeParam() {
  SuperTypeParam.call(this, 'Nicholas') // 继承，先调用超类型构造函数
  this.age = 29 // 再添加子类型中定义的属性
}
var instance10 = new SubTypeParam()
console.log(instance10.name, instance10.age) // Nicholas 29
```

### 借用构造函数的问题

- 同**构造函数模式**存在的问题 —— 方法都在超类型构造函数中定义，**每个方法都会在实例上创建一遍，函数无法复用**，且**超类型的原型中定义的方法，在子类型中不可见**。

## 组合继承

- 又称**经典继承**，使用**原型链**实现**原型属性和方法的继承**，通过**借用构造函数**实现**实例属性的继承**
- 既通过超类型原型上定义的方法实现了**函数复用**，又保证每个实例有自己的属性

```js
/* 超类型构造函数 */
function SuperTypeMix(name) {
  this.name = name
  this.nums = [1, 2, 3]
}
SuperTypeMix.prototype.sayName = function () {
  console.log(this.name)
}
/* 子类型构造函数 */
function SubTypeMix(name, age) {
  SuperTypeMix.call(this) // 借用构造函数继承，继承属性
  this.age = age
}
SubTypeMix.prototype = new SuperTypeMix() // 原型链继承，继承方法
SubTypeMix.prototype.sayAge = function () {
  console.log(this.age) // 子类型原型添加方法（须在替换原型语句之后）
}

var instance11 = new SubTypeMix('Nicholas', 29)
instance11.nums.push(4)
console.log(instance11.nums) // [ 1, 2, 3, 4 ]，借用构造函数继承而来，属性保存在超类型实例中
console.log(instance11.sayName) // 'Nicholas'，原型链继承而来，方法保存在超类型原型中
console.log(instance11.sayAge) // 29，非继承，方法保存在子类型原型中

var instance12 = new SubTypeMix('Greg', 27)
console.log(instance12.nums) // [ 1, 2, 3]
console.log(instance12.sayName) // 'Greg'
console.log(instance12.sayAge) // 27
```

## 总结 & 问点

- 什么是函数签名？为什么 JS 函数没有签名？
- JS 通过什么办法实现原型链上的继承？其原理是什么？
- 继承的意义在于什么？超类型实例上的属性和方法保存在哪些位置？原型上的方法呢？
- 调用子类型构造函数创建实例后，由于子类型的原型被重写，实例的[[Prototype]]和 constructor 指针发生了怎样的变化？为什么？
- 所有引用类型都默认继承了哪个对象？所有函数的默认原型都是什么？默认原型内部的[[Prototype]]指向哪里？
- 在实例中调用 toString()、valueOf()等常用方法时，实际调用的是哪里的方法？
- 有哪些方法可以确定原型和实例的关系？其分别含义和用法是什么？
- 通过原型链实现继承时，为什么给原型添加或重写的方法一定要放在替换原型语句之后？为什么不能使用对象字面量创建原型方法？
- 单独使用原型链实现继承有哪些局限？
- 借用构造函数继承的原理是什么？相比原型链继承有什么优势？其缺点又是什么？
- 组合继承的原理是什么？作为最常用的继承模式，其有哪些优势？
