# 创建对象

- 创建单个对象：Object 构造函数 和 对象字面量
- 缺点：使用一个接口创建很多对象，产生大量重复代码

## 工厂模式

- 抽象了创建具体对象的过程
- 用函数来封装以特定接口创建对象的细节

```js
function createPerson(name, age, job) {
  var o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function () {
    console.log(this.name)
  }
  return o
}
var person1 = createPerson('Nicholas', 29, 'Engineer')
var person2 = createPerson('Greg', 27, 'Doctor')
console.log(person1)
console.log(person2)
```

- 工厂模式解决了创建多个相似对象的问题，但没有解决对象识别问题——即怎样知道一个对象的类型

## 构造函数模式

- 除了 Object 和 Array 等原生构造函数，还可以创建自定义的构造函数

```js
function Person(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function () {
    console.log(this.name)
  }
}
var person1 = Person('Nicholas', 29, 'Software Engineer')
var person2 = Person('Greg', 27, 'Doctor')
```

- 构造函数模式 vs 工厂模式：① 不显式的创建对象；② 直接将属性和方法赋给 this 对象；③ 没有 return
- 构造函数 new 一个对象后：① 创建了一个新对象；② 将构造函数的作用于赋给了新对象；③ 执行构造函数中的代码（即：为这个对象添加新属性）；④ 返回新对象
- 构造函数用大写字母开头，创建实例时用 new 操作符
- 创建的对象的 constructor 属性指向构造函数
- 创建的对象既是 Object 的实例，又是构造函数的实例

```js
console.log(person1.constructor === Person) // true，constructor 属性指向构造函数
console.log(person2.constructor === Person) // true，constructor 属性指向构造函数
console.log(person1 instanceof Object) // true，是 Object 的实例
console.log(person1 instanceof Person) // true，也是 Person 的实例
console.log(person2 instanceof Object) // true，是 Object 的实例
console.log(person2 instanceof Person) // true，也是 Person 的实例
```

- 可以将自定义构造函数的实例标识为一种特定的类型，这是构造函数模式胜过工厂模式的地方
- 以该方法定义的构造函数是定义在 Global 对象中的，在浏览器中则是 window 对象

```js
// 构造函数vs普通函数
var person3 = new Person('Nicholas', 29, 'Software Engineer') // 用构造函数创建对象
person3.sayName() // 'Nicholas'
Person('Greg', 27, 'Doctor') // 不使用new操作符，直接调用
global.sayName() // 直接调用函数时，this指向Global对象（浏览器中指向window对象）
var o = new Object() // 新对象o
var p = new Object() // 新对象p
Person.call(o, 'Kristen', 25, 'Nurse') // 扩充作用域，在对象o中调用Person()函数，call()分别传入每个参数
Person.apply(p, ['Kristen', 25, 'Nurse']) // 扩充作用域，在对象p中调用Person()函数，apply()传入参数数组
o.sayName() // 'Kristen'
p.sayName() // 'Kristen'
```

- 构造函数的问题在于，对象的每个方法都要在每个实例上重新创建一遍，既“每定义一个函数，就实例化一个对象”
- 而创建 2 个完成同样任务的 Function 实例没有必要

```js
function Person2(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayName = new Function(console.log(this.name)) // 与声明函数逻辑等价，每创建一个对象就要创建一个Function实例
}
console.log(person1.sayName === person2.sayName) // false，新对象的2个方法的作用域链和标识符解析不同
```

- 将对象的方法移到构造函数外部，避免多次创建 Function 实例

```js
function Person3(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayName = sayName
}
function sayName() {
  console.log(this.name) // 将sayName设置成全局函数
}
var person4 = new Person('Nicholas', 29, 'Software Engineer')
```

- 构造函数仍未解决的问题：① 创建的全局函数实际上只需要被某个对象中调用；② 若对象有多个方法，则需创建很多全局对象

## 原型模式

- 每个函数都有 prototype 原型属性，该属性是一个指针，指向函数的原型对象，并包含特定类型的所有实例共享的属性和方法，即“通过调用构造函数-而创建的那个对象实例的-原型对象”
- 使用原型对象的好处是，其所有对象实例共享其所包含的属性和方法

```js
function PersonPrototype() {}
PersonPrototype.prototype.name = 'Nicholas' // 为PersonPrototype的原型对象添加属性
PersonPrototype.prototype.age = 29 // 为PersonPrototype的原型对象添加属性
PersonPrototype.prototype.job = 'Software Engineer' // 为PersonPrototype的原型对象添加属性
PersonPrototype.prototype.sayName = function () {
  // 为PersonPrototype的原型对象添加方法
  console.log(this.name)
}
var person5 = new PersonPrototype()
var person6 = new PersonPrototype()
person5.sayName() // 'Nicholas'
person6.sayName() // 'Nicholas'
console.log(person5.sayName === person6.sayName) // true，prototype上创建的属性和方法，由新对象的所有实例共享
```

## 总结 & 问点

- 创建单个对象有哪些方法？这些方法有什么缺点？
- 工厂模式做出了怎样的优化？该模式有什么缺点？
- 相比工厂模式，构造函数模式有哪些区别？如何创建其实例？
- 构造函数在 new 的过程中都发生了什么？
- 构造函数创建出的对象，其 construtor 属性指向哪里？这样的对象是哪些构造函数的实例？
- 相比工厂模式，构造函数有什么优势？
- 构造函数与普通函数有什么相同点和区别？
- 自定义对象的方法时，构造函数模式有什么缺点？
- 用全局函数代替构造函数内部的对象属性的方法，仍有什么缺点？
- prototype 属性的含义和用法？使用原型对象的好处是什么？
